/*
 * Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

/*
 * This source code is provided to illustrate the usage of a given feature
 * or technique and has been deliberately simplified. Additional steps
 * required for a production-quality application, such as security checks,
 * input validation and proper error handling, might not be present in
 * this sample code.
 */


package org.visualheap.debugger;

import com.sun.jdi.*;
import com.sun.jdi.event.*;
import com.sun.jdi.request.*;
import org.visualheap.app.HeapListener;
import org.visualheap.debugger.Breakpoint;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;

/**
 * This class processes incoming JDI events and displays them
 *
 * @author Robert Field
 * @author Oliver Myerscough
 */
class DebuggerEventThread extends Thread {

    private final VirtualMachine vm;   // Running VM

    private boolean connected = true;  // Connected to VM
    private boolean vmDied = true;     // VMDeath occurred

	private AggregatingDebugListener listener = new AggregatingDebugListener();
	
	private List<Breakpoint> breakpointsToAdd = new Vector<Breakpoint>();
	private List<Location> validBreakpointLines = new Vector<Location>();

	private ThreadReference lastBreakpointedThread;
    private String lastBreakpointedClassName;

	/**
	 * construct an event thread, with preset breakpoint.
	 * @param vm virtual machine to observe
	 * @param listener DebugListener instance to call back to
	 */
    DebuggerEventThread(VirtualMachine vm, DebugListener listener) {
        super("event-handler");
        this.vm = vm;
        
        addListener(listener);
        
        setEventRequests();
    }

    /**
     * add a listener for events generated by this thread
     * @param toAdd The listener to add
     * @see DebugListner
     */
    public void addListener(DebugListener toAdd) {
    	listener.addListener(toAdd);		
	}

	/**
     * Run the event handling thread.
     * As long as we are connected, get event sets off
     * the queue and dispatch the events within them.
     */
    @Override
    public void run() {
        EventQueue queue = vm.eventQueue();
        while (connected) {
            try {
                EventSet eventSet = queue.remove();
                EventIterator it = eventSet.eventIterator();
                boolean shouldResume = true;
				while (it.hasNext()) {
                    shouldResume = shouldResume && handleEvent(it.nextEvent());
                }
                
                if(shouldResume) {
                	eventSet.resume();
                }
                
            } catch (InterruptedException exc) {
                // Ignore
            } catch (VMDisconnectedException discExc) {
                handleDisconnectedException();
                break;
            }
        }
    }
    
    public List<Location> getBreakpointableLines(ReferenceType classType) throws AbsentInformationException {
        
        List<Location> lines = new LinkedList<Location>();
        
        for(Location loc : classType.allLineLocations()) {
            lines.add(loc);
        }
        
        return lines;
    }

	private void setBreakpoint(ReferenceType classType, Breakpoint bp) {
		Location bpLoc = null;
		for(Location line : validBreakpointLines) {
        	
        	System.out.println(classType.name() + " line number " + line.lineNumber());
        	if(line.declaringType().equals(classType) && line.lineNumber() == bp.getLine()) {
        		bpLoc = line;
        	}
        }
		
		if(bpLoc != null) {
	    	BreakpointRequest bpReq = vm.eventRequestManager()
	    			.createBreakpointRequest(bpLoc);
	    	bpReq.setSuspendPolicy(EventRequest.SUSPEND_ALL);
	    	bpReq.enable();
		} else {
			System.err.println("couldn't set breakpoint");
			throw new RuntimeException("couldn't set breakpoint");
		}
	}


    /**
     * Create the desired event requests, and enable
     * them so that we will get events.
     */
    private void setEventRequests() {
        EventRequestManager mgr = vm.eventRequestManager();
        
        // want all exceptions
        ExceptionRequest excReq = mgr.createExceptionRequest(null,
                                                             true, true);

        // suspend so we can step
        excReq.setSuspendPolicy(EventRequest.SUSPEND_ALL);
        excReq.enable();


        ThreadDeathRequest tdr = mgr.createThreadDeathRequest();
        // Make sure we sync on thread death
        tdr.setSuspendPolicy(EventRequest.SUSPEND_ALL);
        tdr.enable();
        
        VMDeathRequest vmdr = mgr.createVMDeathRequest();
        vmdr.setSuspendPolicy(EventRequest.SUSPEND_ALL); // is this necessary?
        vmdr.enable();

        // stop on class prepare so we can check if the loaded class is one
        // we want to set a breakpoint in
        ClassPrepareRequest cpr = mgr.createClassPrepareRequest();
        cpr.setSuspendPolicy(EventRequest.SUSPEND_ALL);
        cpr.enable();

    }
   

    /**
     * Dispatch incoming events
     */
    private boolean handleEvent(Event event) {
    	boolean shouldResume = true;
        if (event instanceof ExceptionEvent) {
            exceptionEvent((ExceptionEvent)event);       
        } else if (event instanceof ClassPrepareEvent) {
            classPrepareEvent((ClassPrepareEvent)event);
        } else if (event instanceof VMStartEvent) {
            vmStartEvent((VMStartEvent)event);
        } else if (event instanceof VMDeathEvent) {
            vmDeathEvent((VMDeathEvent)event);
        } else if (event instanceof VMDisconnectEvent) {
        	System.out.println("vm disconnect");
            vmDisconnectEvent((VMDisconnectEvent)event);
        } else if (event instanceof BreakpointEvent) {
        	shouldResume = false;
            breakpointEvent((BreakpointEvent)event);
        } else if (event instanceof StepEvent) {
        	shouldResume = false;
        	stepEvent((StepEvent) event);
        } else if (event instanceof ThreadDeathEvent) {
        	threadDeathEvent((ThreadDeathEvent)event);
        } else if (event instanceof MethodExitEvent) {
            methodExitEvent((MethodExitEvent)event);
        } else {
            throw new Error("Unexpected event type " + event.toString());
        }
        return shouldResume;
    }

    private void threadDeathEvent(ThreadDeathEvent event) {
    	System.out.println("thread death");	
	}
    private void methodExitEvent(MethodExitEvent event) {
    	if (event.method().name().equals("main")) {
    		listener.exitedMain();
	    }
	}

	/***
     * A VMDisconnectedException has happened while dealing with
     * another event. We need to flush the event queue, dealing only
     * with exit events (VMDeath, VMDisconnect) so that we terminate
     * correctly.
     */
    private synchronized void handleDisconnectedException() {
        EventQueue queue = vm.eventQueue();
        while (connected) {
            try {
                EventSet eventSet = queue.remove();
                EventIterator iter = eventSet.eventIterator();
                while (iter.hasNext()) {
                    Event event = iter.nextEvent();
                    if (event instanceof VMDeathEvent) {
                        vmDeathEvent((VMDeathEvent)event);
                    } else if (event instanceof VMDisconnectEvent) {
                        vmDisconnectEvent((VMDisconnectEvent)event);
                    }
                }
                eventSet.resume(); // Resume the VM
            } catch (InterruptedException exc) {
                // ignore
            }
        }
    }

    private void vmStartEvent(VMStartEvent event)  {
    	vm.suspend();
			//Wait for the user begin debugging
			listener.vmStart();
    }

    private void breakpointEvent(BreakpointEvent event)  {
    	//vm.suspend(); // just to be safe
    	ThreadReference thread = event.thread();
    	lastBreakpointedThread = event.thread();
      
      
      EventRequestManager mgr = vm.eventRequestManager();
      MethodExitRequest mer = mgr.createMethodExitRequest();
      mer.setSuspendPolicy(EventRequest.SUSPEND_NONE);
      mer.addThreadFilter(thread);
      mer.enable();
      
        
      StackFrame sf = getStackFrame(thread);
      listener.onBreakpoint(sf);
    }

    private StackFrame getStackFrame(ThreadReference thread) {
        try {
            StackFrame sf = thread.frame(0);
            return sf;
        } catch (IncompatibleThreadStateException e) {
            // means the thread was not suspended, but obviously it will be
            e.printStackTrace();
        }
        return null;
    }

    
    /**
     * handles a step event
     * removes the old {@link StepRequest} from the VM
     * @param event the step event
     * @see DebuggerEventThread . step
     */
    private void stepEvent(StepEvent event) {
    	System.out.println("step event");
    	event.request().disable();
    	listener.onStep(getStackFrame(lastBreakpointedThread));
    }

    /**
     * A new class has been loaded.
     * Set watchpoint on each of its fields
     */
    private void classPrepareEvent(ClassPrepareEvent event)  {
        //EventRequestManager mgr = vm.eventRequestManager();
        
        ReferenceType refType = event.referenceType();
        
        
        
        for(Breakpoint bp : breakpointsToAdd) {
	        if(refType.name().equals(bp.getClassName())) {
	            try {
	                List<Location> test = getBreakpointableLines(refType);
	                validBreakpointLines.addAll(test);
	            } catch (AbsentInformationException e) {
	                e.printStackTrace();
	            }
	        	System.out.println("found " + bp.getClassName());
	        	
	        	setBreakpoint(refType, bp);
	        }
        }
        
    
    }

    private void exceptionEvent(ExceptionEvent event) {
   
    }

    public void vmDeathEvent(VMDeathEvent event) {
        vmDied = true;
        listener.vmDeath();
    }

    public void vmDisconnectEvent(VMDisconnectEvent event) {
    	System.out.println("vm disconnect event");
        listener.vmDeath();
        System.out.println("called vmDeath");
        connected = false;
    }

    /**
     * Add breakpoint.
     * @param className The class to breakpoint.
     * @param breakpointLine The line to break at.
     */
	public void addBreakpoint(String className, int breakpointLine) {
		
		Breakpoint bp = new Breakpoint(className, breakpointLine);
		
		List<ReferenceType> classes = vm.classesByName(className);
		if(classes.isEmpty()) {	
			// add this later
			breakpointsToAdd.add(bp);
		} else {
			setBreakpoint(classes.get(0), bp);
		}
		
		
		
	}


	/**
	 * step the VM.
	 * as we create breakpoints with SUSPEND_ALL, only one breakpoint
	 * can be reached at a time. So the thread to step is the last
	 * breakpointed thread.
	 * @param depth STEP_IN, STEP_OUT, STEP_OVER. Default STEP_OVER.
	 */
	public void step() {
		step(StepDepth.STEP_OVER);
	}
	
	public void step(StepDepth depth) {
		
		System.out.println("step eventthread");
		
		ThreadReference threadToStep = lastBreakpointedThread;
		
		
		
		// TODO step_over, step_out etc
		StepRequest stepRequest = vm.eventRequestManager()
				.createStepRequest(threadToStep, 
						StepRequest.STEP_LINE, depth.toStepRequestDepth());
		stepRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);
		stepRequest.addCountFilter(1);
		stepRequest.enable();
		
		vm.resume();
	}
	
}
